{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "pdfview",
  "type": "registry:ui",
  "title": "PDF View",
  "description": "PDF View component",
  "dependencies": [
    "nanoid",
    "konva",
    "react-konva",
    "pdfjs-dist"
  ],
  "files": [
    {
      "path": "src/registry/pdfview/pdfview.tsx",
      "content": "'use client'\n\nimport { cn } from '@/lib/utils'\nimport {\n  GAP_BETWEEN_PAGES_ON_CANVAS,\n  PDF_PAGE_LOAD_SCALE,\n  PDF_PAGE_STROKE_COLOR,\n  ZOOM_BY_FACTOR,\n  ZOOM_MAX,\n  ZOOM_MIN,\n} from '@/registry/pdfview/pdfview-constants'\nimport { PDFLoader } from '@/registry/pdfview/pdfview-loader'\nimport {\n  Object,\n  PDFViewContext,\n  PDFViewState,\n} from '@/registry/pdfview/pdfview-provider'\nimport {\n  calculateMinMaxX,\n  calculateXClamping,\n  calculateXForScale,\n  calculateYClamping,\n  findClosestPage,\n  invertRemapRange,\n  remapRange,\n} from '@/registry/pdfview/pdfview-utils'\nimport type Konva from 'konva'\nimport { Vector2d } from 'konva/lib/types'\nimport React, { useContext, useEffect, useMemo, useRef, useState } from 'react'\n\nimport { Group, Image, Layer, Rect, Stage, Transformer } from 'react-konva'\n\nfunction PDFView<ContainerRef extends HTMLElement>(props: {\n  src: string\n  containerRef: React.RefObject<ContainerRef | null>\n\n  RenderObject?: React.ComponentType<{\n    object: Object\n    remove: () => void\n  }>\n}) {\n  const context = useContext(PDFViewContext)\n  if (!context) throw new Error('PDFView must be child of PDFViewProvider.')\n\n  const [state, setState] = context\n  const loaderRef = useRef<PDFLoader>(null)\n\n  useEffect(\n    function loadDocumentAndPages() {\n      if (props.containerRef.current === null) return\n\n      const container = props.containerRef.current\n      const rect = container.getBoundingClientRect()\n      setState((prev) => ({\n        ...prev,\n        width: rect.width,\n        height: rect.height,\n      }))\n\n      const loader = new PDFLoader()\n\n      loader\n        .load(props.src, PDF_PAGE_LOAD_SCALE)\n        .then(({ pdf, dominantPageWidth, pageDimensions }) => {\n          const pagePositions = loader.calculatePagePositions({\n            pageDimensions,\n            dominantPageWidth,\n            viewportWidth: rect.width,\n            pageGap: GAP_BETWEEN_PAGES_ON_CANVAS,\n          })\n\n          setState((prev) => ({\n            ...prev,\n            status: 'success',\n            dominantPageWidth,\n            pageDimensions,\n            pagePositions,\n            totalPages: pdf.numPages,\n\n            objectToPlace: null,\n            selectedObjectKey: null,\n            objects: new Map(),\n            pageObjects: new Map(),\n          }))\n        })\n        .catch((e) => {\n          setState((prev) => ({\n            ...prev,\n            status: 'error',\n          }))\n          console.error('[PDFView] Failed to load document. Cause:', e)\n        })\n      loaderRef.current = loader\n\n      let updatViewportDimensionsTimer: NodeJS.Timeout | null = null\n\n      const resizeObserver = new ResizeObserver((entries) => {\n        const rect = entries[0].contentRect\n\n        if (updatViewportDimensionsTimer !== null) {\n          clearTimeout(updatViewportDimensionsTimer)\n        }\n        updatViewportDimensionsTimer = setTimeout(() => {\n          setState((prev) => {\n            if (prev.dominantPageWidth === 0) return prev\n\n            const pagePositions = loader.calculatePagePositions({\n              pageDimensions: prev.pageDimensions,\n              dominantPageWidth: prev.dominantPageWidth,\n              viewportWidth: rect.width,\n              pageGap: GAP_BETWEEN_PAGES_ON_CANVAS,\n            })\n\n            return {\n              ...prev,\n              pagePositions,\n              width: rect.width,\n              height: rect.height,\n            }\n          })\n        }, 150)\n      })\n\n      resizeObserver.observe(container)\n\n      const controller = new AbortController()\n      window.addEventListener(\n        'keydown',\n        (e) => {\n          if (e.key === 'Escape') {\n            setState((prev) => {\n              return {\n                ...prev,\n                selectedObjectKey: null,\n                objectToPlace: null,\n              }\n            })\n          }\n\n          if (e.key === 'Backspace' || e.key === 'Delete') {\n            setState((prev) => {\n              const selectedObjectKey = prev.selectedObjectKey\n              if (!selectedObjectKey) return prev\n\n              const objects = new Map(prev.objects)\n              objects.delete(selectedObjectKey!)\n\n              const pageObjects = new Map(prev.pageObjects)\n              if (pageObjects.has(prev.currentPage)) {\n                const pageObjectIds = pageObjects.get(prev.currentPage)!\n                const objectIds = pageObjectIds.filter(\n                  (id) => id !== selectedObjectKey,\n                )\n\n                pageObjects.set(prev.currentPage, objectIds)\n              }\n\n              return {\n                ...prev,\n                objects,\n                pageObjects,\n                selectedObjectKey: null,\n              }\n            })\n          }\n        },\n        {\n          signal: controller.signal,\n        },\n      )\n\n      return () => {\n        controller.abort()\n        resizeObserver.disconnect()\n        loaderRef.current?.dispose()\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [props.src],\n  )\n\n  function handleWheelLayer(e: Konva.KonvaEventObject<WheelEvent>) {\n    e.evt.preventDefault()\n\n    const layer = e.currentTarget as Konva.Layer\n    const stage = layer.getStage()\n\n    const deltaY = e.evt.deltaY\n    const deltaX = e.evt.deltaX\n    const pointer = stage.getPointerPosition()!\n\n    const modPressed = e.evt.ctrlKey || e.evt.metaKey\n\n    updateStateOnWheel({ deltaX, deltaY, modPressed, pointer })\n  }\n\n  function handleWheelStage(e: Konva.KonvaEventObject<WheelEvent>) {\n    e.evt.preventDefault()\n\n    const stage = e.currentTarget as Konva.Stage\n\n    const deltaY = e.evt.deltaY\n    const deltaX = e.evt.deltaX\n    const pointer = stage.getPointerPosition()!\n\n    const modPressed = e.evt.ctrlKey || e.evt.metaKey\n\n    updateStateOnWheel({ deltaX, deltaY, modPressed, pointer })\n  }\n\n  function updateStateOnWheel(params: {\n    deltaX: number\n    deltaY: number\n    modPressed: boolean\n    pointer: Konva.Vector2d\n  }) {\n    const deltaY = params.deltaY\n    const deltaX = params.deltaX\n    const direction = params.deltaY > 0 ? -1 : 1\n    const zoomBy = params.modPressed ? ZOOM_BY_FACTOR : 1\n    const pointer = params.pointer\n\n    setState((state) => {\n      if (zoomBy !== 1) {\n        const newScale =\n          direction > 0\n            ? Math.min(state.scale * zoomBy, ZOOM_MAX)\n            : Math.max(state.scale / zoomBy, ZOOM_MIN)\n        const mousePointToY = (pointer.y - state.y) / state.scale\n\n        const newX = calculateXForScale(state.width, newScale)\n        const newY = calculateYClamping(pointer.y - mousePointToY * newScale, {\n          ...state,\n          scale: newScale,\n        })\n\n        return {\n          ...state,\n          y: newY,\n          x: newX,\n          scale: newScale,\n        }\n      }\n\n      const closestPage = findClosestPage(state)\n      const newY = calculateYClamping(state.y - deltaY, state)\n      const newX = calculateXClamping(state.x - deltaX, state)\n\n      return {\n        ...state,\n        currentPage: closestPage,\n        y: newY,\n        x: newX,\n      }\n    })\n  }\n\n  if (state.status === 'loading') {\n    return null\n  }\n\n  const buffer = 2 * state.height\n  const visiblePages = state.pagePositions.filter((pos) => {\n    const pageTop = pos.position.y * state.scale\n    const pageBottom = pageTop + pos.dimensions.height * state.scale\n    const viewportTop = -state.y\n    const viewportBottom = viewportTop + state.height\n\n    return (\n      pageBottom >= viewportTop - buffer && pageTop <= viewportBottom + buffer\n    )\n  })\n\n  return (\n    <Stage\n      width={state.width}\n      height={state.height}\n      onWheel={handleWheelStage}\n      onMouseMove={(e) => {\n        const stage = e.currentTarget as Konva.Stage\n        const pointer = stage.getPointerPosition()!\n\n        setState((prev) => ({\n          ...prev,\n          pointer,\n        }))\n      }}\n      onClick={() => {\n        setState((prev) => ({\n          ...prev,\n          selectedObjectKey: null,\n          objectToPlace: null,\n        }))\n      }}\n      className={cn('overflow-hidden', {\n        // 'cursor-none': state.objectToPlace,\n      })}>\n      <Layer\n        scaleX={state.scale}\n        scaleY={state.scale}\n        x={state.x}\n        y={state.y}\n        onWheel={handleWheelLayer}>\n        {visiblePages.map(({ pageNumber, dimensions, position }) => {\n          return (\n            <PDFPage\n              key={pageNumber}\n              loaderRef={loaderRef}\n              pageNumber={pageNumber}\n              dimensions={dimensions}\n              position={position}\n              RenderObject={props.RenderObject}\n            />\n          )\n        })}\n      </Layer>\n\n      <Layer>\n        <ScrollbarY\n          state={state}\n          onYUpdate={(y) => setState((prev) => ({ ...prev, y }))}\n        />\n        <ScrollbarX\n          state={state}\n          onXUpdate={(x) => setState((prev) => ({ ...prev, x }))}\n        />\n\n        {state.objectToPlace && props.RenderObject && (\n          <MouseCursor\n            scale={state.scale}\n            pointer={state.pointer}\n            objectToPlace={state.objectToPlace}\n            RenderObject={props.RenderObject}\n          />\n        )}\n      </Layer>\n    </Stage>\n  )\n}\n\nfunction PDFPage(props: {\n  loaderRef: React.RefObject<PDFLoader | null>\n  pageNumber: number\n  dimensions: { width: number; height: number }\n  position: {\n    x: number\n    y: number\n  }\n\n  RenderObject?: React.ComponentType<{\n    object: Object\n    remove: () => void\n  }>\n}) {\n  const context = useContext(PDFViewContext)\n  if (!context) throw new Error('PDFView must be child of PDFViewProvider.')\n  const [state, setState] = context\n\n  const groupRef = useRef<Konva.Group>(null)\n  const [image, setImage] = useState<HTMLCanvasElement | undefined>(undefined)\n\n  useEffect(\n    function loadPage() {\n      const loader = props.loaderRef.current\n      if (loader === null) return\n\n      setTimeout(() => {\n        loader\n          .loadPage(props.pageNumber, PDF_PAGE_LOAD_SCALE)\n          .then(({ canvas }) => {\n            setImage(canvas)\n          })\n          .catch((e) => {\n            console.error('[PDFPage] Failed to load page. Cause:', e)\n          })\n      }, 300)\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [props.pageNumber],\n  )\n\n  const RenderObject = props.RenderObject\n  const objects = useMemo(() => {\n    if (!RenderObject) return []\n    const objectIds = state.pageObjects.get(props.pageNumber) ?? []\n\n    const objects = [] as Object[]\n    for (const objectId of objectIds) {\n      const object = state.objects.get(objectId)\n      if (object) objects.push(object)\n    }\n\n    return objects\n  }, [props.pageNumber, RenderObject, state.pageObjects, state.objects])\n\n  function placeObject(pageNumber: number, pointer: Vector2d) {\n    if (!state.objectToPlace) return\n\n    const newObject = {\n      id: state.objectToPlace.id,\n      position: pointer,\n      dimensions: state.objectToPlace.dimensions,\n      tag: state.objectToPlace.tag,\n      data: state.objectToPlace.data,\n      placed: true,\n    }\n\n    setState((prev) => {\n      const objects = new Map(prev.objects)\n      objects.set(newObject.id, newObject)\n\n      const pageObjects = new Map(prev.pageObjects)\n      if (!pageObjects.has(pageNumber)) {\n        pageObjects.set(pageNumber, [])\n      }\n\n      const pageObjectIds = pageObjects.get(pageNumber)!\n      if (!pageObjectIds.includes(newObject.id))\n        pageObjects.get(pageNumber)!.push(newObject.id)\n\n      return {\n        ...prev,\n        objects: objects,\n        pageObjects: pageObjects,\n        objectToPlace: null,\n      }\n    })\n\n    setTimeout(() => {\n      setState((prev) => ({\n        ...prev,\n        selectedObjectKey: newObject.id,\n      }))\n    }, 100)\n  }\n\n  return (\n    <Group\n      {...props.position}\n      clipX={0}\n      clipY={0}\n      clipWidth={props.dimensions.width}\n      clipHeight={props.dimensions.height}\n      ref={groupRef}\n      onClick={(e) => {\n        const group = e.currentTarget as Konva.Group\n        const localPos = group.getRelativePointerPosition()!\n\n        placeObject(props.pageNumber, localPos)\n      }}>\n      {!image && (\n        <Rect\n          {...props.dimensions}\n          fill={'white'}\n          stroke={PDF_PAGE_STROKE_COLOR}\n          strokeWidth={1}\n        />\n      )}\n      {image && (\n        <Image\n          {...props.dimensions}\n          x={0.5}\n          y={0.5}\n          width={props.dimensions.width - 1}\n          height={props.dimensions.height - 1}\n          image={image}\n          stroke={PDF_PAGE_STROKE_COLOR}\n          strokeWidth={1 / state.scale}\n          strokeAfterFill={true}\n          alt={`Page ${props.pageNumber}`}\n        />\n      )}\n\n      {image &&\n        objects.map((object) => {\n          return (\n            <ObjectContainer\n              key={object.id}\n              object={object}\n              RenderObject={RenderObject!}\n            />\n          )\n        })}\n    </Group>\n  )\n}\n\nfunction ObjectContainer(props: {\n  object: Object\n  RenderObject: React.ComponentType<{\n    object: Object\n    remove: () => void\n  }>\n}) {\n  const context = useContext(PDFViewContext)\n  if (!context) throw new Error('PDFView must be child of PDFViewProvider.')\n  const [state, setState] = context\n\n  const width = props.object.dimensions.width\n  const height = props.object.dimensions.height\n  const x = props.object.position.x - width / 2\n  const y = props.object.position.y - height / 2\n\n  const selected = props.object.id === state.selectedObjectKey\n  const groupRef = useRef<Konva.Group>(null)\n  const transformerRef = useRef<Konva.Transformer>(null)\n\n  useEffect(() => {\n    if (selected && transformerRef.current && groupRef.current) {\n      transformerRef.current.nodes([groupRef.current])\n      transformerRef.current.getLayer()?.batchDraw()\n    }\n  }, [selected])\n\n  return (\n    <>\n      <Group\n        draggable\n        onTransformEnd={(e) => {\n          const group = e.target\n          const pos = group.position()\n          const size = group.size()\n\n          setState((prev) => {\n            const objects = new Map(prev.objects)\n            objects.set(props.object.id, {\n              ...props.object,\n              position: {\n                x: pos.x + size.width / 2,\n                y: pos.y + size.height / 2,\n              },\n            })\n\n            return {\n              ...prev,\n              objects,\n            }\n          })\n        }}\n        onDragStart={() => {\n          setState((prev) => {\n            return {\n              ...prev,\n              selectedObjectKey: props.object.id,\n            }\n          })\n        }}\n        onDragEnd={(e) => {\n          const group = e.target\n          const pos = group.position()\n          const size = group.size()\n\n          setState((prev) => {\n            const objects = new Map(prev.objects)\n            objects.set(props.object.id, {\n              ...props.object,\n              position: {\n                x: pos.x + size.width / 2,\n                y: pos.y + size.height / 2,\n              },\n            })\n\n            return {\n              ...prev,\n              objects,\n            }\n          })\n        }}\n        ref={groupRef}\n        width={width}\n        height={height}\n        x={x}\n        y={y}\n        onClick={(e) => {\n          e.cancelBubble = true\n\n          setState((prev) => {\n            return {\n              ...prev,\n              selectedObjectKey: props.object.id,\n            }\n          })\n        }}>\n        <props.RenderObject\n          object={props.object}\n          remove={() => {\n            setState((prev) => {\n              const objects = new Map(prev.objects)\n              objects.delete(props.object.id)\n\n              const pageObjects = new Map(prev.pageObjects)\n              if (pageObjects.has(prev.currentPage)) {\n                const pageObjectIds = pageObjects.get(prev.currentPage)!\n                const objectIds = pageObjectIds.filter(\n                  (id) => id !== props.object.id,\n                )\n\n                pageObjects.set(prev.currentPage, objectIds)\n              }\n\n              return {\n                ...prev,\n                objects,\n                pageObjects,\n                selectedObjectKey: null,\n              }\n            })\n          }}\n        />\n      </Group>\n\n      {selected && (\n        <Transformer\n          ref={transformerRef}\n          rotateEnabled={false}\n          keepRatio={true}\n          enabledAnchors={[\n            'top-left',\n            'top-right',\n            'bottom-left',\n            'bottom-right',\n          ]}\n          boundBoxFunc={(oldBox, newBox) => {\n            const minSize = 20 * state.scale\n            if (newBox.width < minSize || newBox.height < minSize) {\n              return oldBox\n            }\n            return newBox\n          }}\n          // border\n          borderStroke=\"black\"\n          borderStrokeWidth={state.scale}\n          borderDash={[4 * state.scale, 4 * state.scale]}\n          borderDashEnabled={true}\n          // anchor\n          anchorSize={3 * state.scale}\n          anchorStroke=\"black\"\n          anchorStrokeWidth={state.scale}\n          anchorFill=\"black\"\n          anchorCornerRadius={100}\n        />\n      )}\n    </>\n  )\n}\n\nfunction MouseCursor(props: {\n  scale: number\n  pointer: Vector2d\n  objectToPlace: Object\n\n  RenderObject: React.ComponentType<{\n    object: Object\n    remove: () => void\n  }>\n}) {\n  const width = props.objectToPlace.dimensions.width * props.scale\n  const height = props.objectToPlace.dimensions.height * props.scale\n  const x = props.pointer.x - width / 2\n  const y = props.pointer.y - height / 2\n\n  return (\n    <Group width={width} height={height} x={x} y={y}>\n      <props.RenderObject\n        object={{\n          ...props.objectToPlace,\n          dimensions: {\n            width: width,\n            height: height,\n          },\n        }}\n        remove={() => {}}\n      />\n    </Group>\n  )\n}\n\nfunction ScrollbarY(props: {\n  state: PDFViewState\n  onYUpdate: (y: number) => void\n}) {\n  const { state } = props\n\n  const lastPagePos = state.pagePositions[state.pagePositions.length - 1]\n  const contentH =\n    lastPagePos.position.y +\n    lastPagePos.dimensions.height +\n    GAP_BETWEEN_PAGES_ON_CANVAS\n  const scaledContentH = contentH * state.scale\n\n  const viewH = state.height\n  const verticalRatio = viewH / scaledContentH\n  const vLen = Math.max(20, viewH * verticalRatio)\n\n  const minY = 2 * state.scale\n  const maxY = state.height - (minY + 10)\n\n  const dY = remapRange(\n    -state.y,\n    -GAP_BETWEEN_PAGES_ON_CANVAS,\n    scaledContentH,\n    minY,\n    maxY,\n  )\n\n  const [dragging, setDragging] = useState(false)\n\n  function dragBoundFunc(pos: Vector2d) {\n    let newY = pos.y\n\n    if (newY < minY) newY = minY\n    if (newY > maxY - vLen) newY = maxY - vLen\n\n    return {\n      y: newY,\n      x: state.width - 9,\n    }\n  }\n\n  return (\n    <Rect\n      draggable\n      dragBoundFunc={dragBoundFunc}\n      onDragStart={() => setDragging(true)}\n      onDragMove={(e) => {\n        const { y: yPos } = e.currentTarget.position()\n\n        const newY = -invertRemapRange(\n          yPos,\n          -GAP_BETWEEN_PAGES_ON_CANVAS,\n          scaledContentH,\n          minY,\n          maxY,\n        )\n        props.onYUpdate(newY)\n      }}\n      onDragEnd={() => setDragging(false)}\n      y={dragging ? undefined : dY}\n      x={state.width - 9}\n      width={6}\n      height={vLen}\n      fill=\"#c9c9c9\"\n      cornerRadius={3}\n    />\n  )\n}\n\nfunction ScrollbarX(props: {\n  state: PDFViewState\n  onXUpdate: (x: number) => void\n}) {\n  const { state } = props\n  const stageW = state.width\n  const horizontalRatio = stageW / (stageW * state.scale)\n  const hLen = stageW * horizontalRatio\n\n  const { minX, maxX } = calculateMinMaxX(state)\n  const newMaxX = stageW - hLen\n  const dX = remapRange(state.x, minX, maxX, newMaxX, 0)\n  const showHScrollbar = state.scale > 1.05\n\n  const [dragging, setDragging] = useState(false)\n\n  function dragBoundFunc(pos: Vector2d) {\n    let newX = pos.x\n\n    if (newX >= newMaxX) newX = newMaxX\n    if (newX < 0) newX = 0\n\n    return {\n      y: state.height - 8,\n      x: newX,\n    }\n  }\n\n  if (!showHScrollbar) return null\n\n  return (\n    <Rect\n      draggable\n      dragBoundFunc={dragBoundFunc}\n      onDragStart={() => setDragging(true)}\n      onDragEnd={() => setDragging(false)}\n      onDragMove={(e) => {\n        const { x: xPos } = e.currentTarget.position()\n        const newX = invertRemapRange(xPos, minX, maxX, newMaxX, 0)\n\n        props.onXUpdate(newX)\n      }}\n      x={dragging ? undefined : dX}\n      y={state.height - 8}\n      width={hLen}\n      height={6}\n      fill=\"#c9c9c9\"\n      cornerRadius={3}\n    />\n  )\n}\n\nexport { PDFView }\n",
      "type": "registry:ui",
      "target": "components/pdfview/pdfview.tsx"
    },
    {
      "path": "src/registry/pdfview/pdfview-provider.tsx",
      "content": "import {\n  GAP_BETWEEN_PAGES_ON_CANVAS,\n  ZOOM_MAX,\n  ZOOM_MIN,\n} from '@/registry/pdfview/pdfview-constants'\nimport { PDFLoader } from '@/registry/pdfview/pdfview-loader'\nimport { calculateXForScale } from '@/registry/pdfview/pdfview-utils'\nimport { Vector2d } from 'konva/lib/types'\nimport React, {\n  useCallback,\n  useContext,\n  useEffect,\n  useMemo,\n  useState,\n} from 'react'\n\nexport type PDFViewState = {\n  status: 'loading' | 'success' | 'error'\n  scale: number\n  width: number\n  height: number\n  x: number\n  y: number\n  dominantPageWidth: number\n  pageDimensions: Map<\n    number,\n    {\n      width: number\n      height: number\n    }\n  >\n  pagePositions: ReturnType<PDFLoader['calculatePagePositions']>\n  currentPage: number\n  totalPages: number\n\n  pointer: Vector2d\n\n  objects: Map<string, Object>\n  pageObjects: Map<number, string[]>\n  selectedObjectKey: string | null\n  objectToPlace: Object | null\n}\n\nexport type Object = {\n  id: string\n  position: Vector2d\n  dimensions: { width: number; height: number }\n  tag: string\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n  data: any\n  placed: boolean\n}\n\nconst PDFViewContext = React.createContext<\n  [PDFViewState, React.Dispatch<React.SetStateAction<PDFViewState>>]\n>(\n  null as unknown as [\n    PDFViewState,\n    React.Dispatch<React.SetStateAction<PDFViewState>>,\n  ],\n)\n\nconst PDFViewActionsContext = React.createContext<{\n  setViewportScale: (scale: number) => void\n  goToPage: (pageNumber: number) => void\n  setObjectToPlace: (\n    objectToPlace: Omit<Object, 'position' | 'placed'> | null,\n  ) => void\n  // eslint-disable-next-line @typescript-eslint/no-explicit-any\n}>(null as any)\n\ntype Actions =\n  typeof PDFViewActionsContext extends React.Context<infer T> ? T : never\n\ndeclare global {\n  interface Window {\n    pdfview: Actions\n  }\n}\n\nfunction PDFViewProvider(props: { children: React.ReactNode }) {\n  const [state, setState] = useState<PDFViewState>({\n    status: 'loading',\n\n    scale: 1,\n\n    width: 0,\n    height: 0,\n\n    x: 0,\n    y: 0,\n\n    dominantPageWidth: 0,\n    pageDimensions: new Map(),\n    pagePositions: [],\n\n    currentPage: 1,\n    totalPages: 1,\n\n    pointer: {\n      x: -1000,\n      y: -1000,\n    },\n\n    objects: new Map(),\n    pageObjects: new Map(),\n    selectedObjectKey: null,\n    objectToPlace: null,\n  })\n\n  const setViewportScale = useCallback((scale: number) => {\n    setState((state) => {\n      const clampedScale = Math.max(Math.min(scale, ZOOM_MAX), ZOOM_MIN)\n      const newX = calculateXForScale(state.width, clampedScale)\n\n      return {\n        ...state,\n        x: newX,\n        scale: clampedScale,\n      }\n    })\n  }, [])\n\n  const goToPage = useCallback((pageNumber: number) => {\n    setState((viewportState) => {\n      const targetPagePos = viewportState.pagePositions.find(\n        (pos) => pos.pageNumber === pageNumber,\n      )\n      if (targetPagePos === undefined) return viewportState\n\n      const targetY =\n        targetPagePos.position.y * viewportState.scale -\n        GAP_BETWEEN_PAGES_ON_CANVAS\n\n      return {\n        ...viewportState,\n        currentPage: pageNumber,\n        y: -targetY,\n      }\n    })\n  }, [])\n\n  const setObjectToPlace = useCallback(\n    (object: Omit<Object, 'position' | 'placed'> | null) => {\n      setState((prev) => ({\n        ...prev,\n        objectToPlace: object\n          ? {\n              ...object,\n              position: {\n                x: 0,\n                y: 0,\n              },\n              placed: false,\n            }\n          : null,\n      }))\n    },\n    [],\n  )\n\n  const actions = useMemo(() => {\n    return {\n      setViewportScale,\n      goToPage,\n      setObjectToPlace,\n    }\n  }, [setViewportScale, goToPage, setObjectToPlace])\n\n  useEffect(() => {\n    window.pdfview = actions\n  }, [actions])\n\n  return (\n    <PDFViewActionsContext.Provider value={actions}>\n      <PDFViewContext.Provider value={[state, setState]}>\n        {props.children}\n      </PDFViewContext.Provider>\n    </PDFViewActionsContext.Provider>\n  )\n}\n\nfunction usePDFViewState() {\n  const context = useContext(PDFViewContext)\n  if (!context) throw new Error('PDFView must be child of PDFViewProvider.')\n\n  const [state] = context\n\n  return {\n    status: state.status,\n    scale: state.scale,\n    currentPage: state.currentPage,\n    totalPages: state.totalPages,\n  }\n}\n\nfunction usePDFViewActions() {\n  const context = useContext(PDFViewActionsContext)\n  if (!context) throw new Error('PDFView must be child of PDFViewProvider.')\n\n  return context\n}\n\nexport { PDFViewContext, PDFViewProvider, usePDFViewActions, usePDFViewState }\n",
      "type": "registry:ui",
      "target": "components/pdfview/pdfview-provider.tsx"
    },
    {
      "path": "src/registry/pdfview/pdfview-utils.ts",
      "content": "import { GAP_BETWEEN_PAGES_ON_CANVAS } from '@/registry/pdfview/pdfview-constants'\nimport type { PDFLoader } from '@/registry/pdfview/pdfview-loader'\n\nexport function calculateYClamping(\n  inputY: number,\n  state: {\n    scale: number\n    pagePositions: ReturnType<PDFLoader['calculatePagePositions']>\n    height: number\n  },\n) {\n  let newY = inputY\n  const scale = state.scale\n  if (newY > 0) newY = 0\n\n  // bottom bounds\n  const lastPagePos = state.pagePositions[state.pagePositions.length - 1]\n  const lastPageHeight = lastPagePos.dimensions.height * scale\n  const lastPageY = lastPagePos.position.y * scale\n  const totalDocHeight = lastPageY + lastPageHeight\n  const maxY =\n    totalDocHeight - state.height + GAP_BETWEEN_PAGES_ON_CANVAS * scale\n  if (newY < -maxY) newY = -maxY\n\n  return newY\n}\n\nexport function calculateMinMaxX(state: {\n  scale: number\n  pagePositions: ReturnType<PDFLoader['calculatePagePositions']>\n  width: number\n  height: number\n  x: number\n}) {\n  const scale = state.scale\n  let largestPagePos = state.pagePositions[0]\n  for (const pagePos of state.pagePositions) {\n    if (pagePos.dimensions.width > largestPagePos.dimensions.width) {\n      largestPagePos = pagePos\n    }\n  }\n\n  const largestPageWidth = largestPagePos.dimensions.width * scale\n  const largestPageX = largestPagePos.position.x * scale\n\n  const docLeft = largestPageX\n  const docRight = largestPageX + largestPageWidth\n\n  const padding = GAP_BETWEEN_PAGES_ON_CANVAS * scale\n\n  const maxX = padding - docLeft\n  const minX = state.width - docRight - padding\n\n  return { minX, maxX, largestPageWidth }\n}\n\nexport function calculateXClamping(\n  inputX: number,\n  state: {\n    scale: number\n    pagePositions: ReturnType<PDFLoader['calculatePagePositions']>\n    width: number\n    height: number\n    x: number\n  },\n) {\n  const { minX, maxX, largestPageWidth } = calculateMinMaxX(state)\n  let newX = inputX\n  if (largestPageWidth <= state.width) {\n    newX = state.x\n  } else {\n    if (newX > maxX) newX = maxX\n    if (newX < minX) newX = minX\n  }\n\n  return newX\n}\n\nexport function findClosestPage(state: {\n  currentPage: number\n  pagePositions: ReturnType<PDFLoader['calculatePagePositions']>\n  y: number\n  height: number\n  scale: number\n}) {\n  let closestPage = state.currentPage\n  let closestDistance = Infinity\n\n  const viewportTop = -state.y\n  const viewportCenter = viewportTop + state.height / 2\n\n  state.pagePositions.forEach((pos) => {\n    const pageTop = pos.position.y * state.scale\n    const pageBottom = pageTop + pos.dimensions.height * state.scale\n    const pageCenter = (pageTop + pageBottom) / 2\n\n    const distance = Math.abs(pageCenter - viewportCenter)\n    if (distance < closestDistance) {\n      closestDistance = distance\n      closestPage = pos.pageNumber\n    }\n  })\n\n  return closestPage\n}\n\nexport function calculateXForScale(width: number, scale: number) {\n  const centerXOriginal = width / 2\n  const centerXScaled = (width * scale) / 2\n  const diff = Math.abs(centerXOriginal - centerXScaled)\n  const newX = diff * (centerXOriginal > centerXScaled ? 1 : -1)\n\n  return newX\n}\n\nexport function remapRange(\n  x: number,\n  minO: number,\n  maxO: number,\n  dMin: number,\n  dMax: number,\n): number {\n  return dMin + ((x - minO) / (maxO - minO)) * (dMax - dMin)\n}\n\nexport function invertRemapRange(\n  xNew: number,\n  minO: number,\n  maxO: number,\n  dMin: number,\n  dMax: number,\n): number {\n  return minO + ((xNew - dMin) / (dMax - dMin)) * (maxO - minO)\n}\n",
      "type": "registry:lib",
      "target": "components/pdfview/pdfview-utils.ts"
    },
    {
      "path": "src/registry/pdfview/pdfview-loader.ts",
      "content": "import type {\n  DocumentInitParameters,\n  TypedArray,\n} from 'pdfjs-dist/types/src/display/api'\n\nimport * as pdfjs from 'pdfjs-dist'\n\npdfjs.GlobalWorkerOptions.workerSrc = new URL(\n  'pdfjs-dist/build/pdf.worker.min.mjs',\n  import.meta.url,\n).toString()\n\nclass PDFLoader {\n  public pdf!: pdfjs.PDFDocumentProxy\n  public pdfLoaded = false\n\n  public async load(\n    src: string | URL | TypedArray | ArrayBuffer | DocumentInitParameters,\n    pageScale: number = 1,\n  ) {\n    const pdf = await pdfjs.getDocument(src).promise\n    this.pdf = pdf\n    this.pdfLoaded = true\n\n    const pages = await Promise.all(\n      Array.from({ length: pdf.numPages }).map((_, i) => pdf.getPage(i + 1)),\n    )\n    const pageDimensions = new Map<\n      number,\n      {\n        width: number\n        height: number\n      }\n    >()\n    const pageWidths = new Map<number, number>()\n    pages.forEach((page) => {\n      const viewport = page.getViewport({ scale: pageScale })\n      const v = pageWidths.get(viewport.width) ?? 1\n      pageWidths.set(viewport.width, v + 1)\n      pageDimensions.set(page.pageNumber, {\n        width: viewport.width,\n        height: viewport.height,\n      })\n    })\n    const reversedMap = new Map(\n      pageWidths.entries().map(([k, v]) => [v, k] as [number, number]),\n    )\n\n    const max = Math.max(...reversedMap.keys())\n    const dominantPageWidth = reversedMap.get(max)\n\n    if (!dominantPageWidth) {\n      throw new Error('Failed to get major page width')\n    }\n\n    return {\n      pdf,\n      dominantPageWidth,\n      pageDimensions,\n    }\n  }\n\n  public calculatePagePositions(opts: {\n    pageDimensions: Map<number, { width: number; height: number }>\n    dominantPageWidth: number\n    viewportWidth: number\n    pageGap: number\n  }) {\n    const { pageDimensions, dominantPageWidth, viewportWidth, pageGap } = opts\n    let prevPageHeight = pageGap\n\n    return pageDimensions\n      .entries()\n      .map(([pageNumber, pageDimensions], index) => {\n        const allowedPageWidth = viewportWidth * 0.8\n        const allowedScale =\n          dominantPageWidth > allowedPageWidth\n            ? allowedPageWidth / dominantPageWidth\n            : 1\n\n        const scaledPageWidth = pageDimensions.width * allowedScale\n        const scaledPageHeight = pageDimensions.height * allowedScale\n\n        const yPosition = prevPageHeight + index * pageGap\n        prevPageHeight += scaledPageHeight\n\n        return {\n          pageNumber,\n          dimensions: {\n            width: scaledPageWidth,\n            height: scaledPageHeight,\n          },\n          position: {\n            x: viewportWidth / 2 - scaledPageWidth / 2,\n            y: yPosition,\n          },\n        }\n      })\n      .toArray()\n  }\n\n  public async loadPage(pageNumber: number, scale: number = 1) {\n    if (this.pdf === null) throw new Error('PDF not loaded yet.')\n\n    const page = await this.pdf.getPage(pageNumber)\n    const viewport = page.getViewport({ scale })\n    const outputScale = window.devicePixelRatio || 1\n\n    const canvas = document.createElement('canvas')\n    const context = canvas.getContext('2d')!\n    canvas.width = Math.floor(viewport.width * outputScale)\n    canvas.height = Math.floor(viewport.height * outputScale)\n    canvas.style.width = Math.floor(viewport.width) + 'px'\n    canvas.style.height = Math.floor(viewport.height) + 'px'\n\n    const transform =\n      outputScale !== 1 ? [outputScale, 0, 0, outputScale, 0, 0] : undefined\n    const renderContext = {\n      canvas,\n      canvasContext: context,\n      transform,\n      viewport,\n    }\n\n    await page.render(renderContext).promise\n\n    return {\n      page,\n      canvas,\n    }\n  }\n\n  public dispose() {\n    this.pdfLoaded = false\n    void this.pdf?.destroy()\n  }\n}\n\nexport { PDFLoader }\n",
      "type": "registry:lib",
      "target": "components/pdfview/pdfview-loader.ts"
    },
    {
      "path": "src/registry/pdfview/pdfview-constants.ts",
      "content": "export const PDF_PAGE_LOAD_SCALE = 2\nexport const GAP_BETWEEN_PAGES_ON_CANVAS = 24\nexport const ZOOM_BY_FACTOR = 1.05\nexport const ZOOM_MAX = 3\nexport const ZOOM_MIN = 0.25\nexport const PDF_PAGE_STROKE_COLOR = '#1E2939'\n",
      "type": "registry:lib",
      "target": "components/pdfview/pdfview-constants.ts"
    }
  ]
}