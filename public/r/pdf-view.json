{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "pdf-view",
  "type": "registry:ui",
  "title": "PDF View",
  "description": "PDFV Viewer component",
  "dependencies": [
    "konva",
    "react-konva",
    "pdfjs-dist"
  ],
  "files": [
    {
      "path": "src/registry/pdf-view/pdf-view.tsx",
      "content": "'use client'\n\nimport { cn } from '@/lib/utils'\nimport Konva from 'konva'\nimport * as pdfjs from 'pdfjs-dist'\nimport type {\n  DocumentInitParameters,\n  TypedArray,\n} from 'pdfjs-dist/types/src/display/api'\nimport React, {\n  useCallback,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n} from 'react'\nimport { FastLayer, Group, Image, Rect, Stage } from 'react-konva'\n\npdfjs.GlobalWorkerOptions.workerSrc = new URL(\n  'pdfjs-dist/build/pdf.worker.min.mjs',\n  import.meta.url,\n).toString()\n\nclass PDFLoader {\n  public pdf!: pdfjs.PDFDocumentProxy\n  public pdfLoaded = false\n\n  public async load(\n    src: string | URL | TypedArray | ArrayBuffer | DocumentInitParameters,\n    pageScale: number = 1,\n  ) {\n    const pdf = await pdfjs.getDocument(src).promise\n    this.pdf = pdf\n    this.pdfLoaded = true\n\n    const pages = await Promise.all(\n      Array.from({ length: pdf.numPages }).map((_, i) => pdf.getPage(i + 1)),\n    )\n    const pageDimensions = new Map<\n      number,\n      {\n        width: number\n        height: number\n      }\n    >()\n    const pageWidths = new Map<number, number>()\n    pages.forEach((page) => {\n      const viewport = page.getViewport({ scale: pageScale })\n      const v = pageWidths.get(viewport.width) ?? 1\n      pageWidths.set(viewport.width, v + 1)\n      pageDimensions.set(page.pageNumber, {\n        width: viewport.width,\n        height: viewport.height,\n      })\n    })\n    const reversedMap = new Map(\n      pageWidths.entries().map(([k, v]) => [v, k] as [number, number]),\n    )\n\n    const max = Math.max(...reversedMap.keys())\n    const dominantPageWidth = reversedMap.get(max)\n\n    if (!dominantPageWidth) {\n      throw new Error('Failed to get major page width')\n    }\n\n    return {\n      pdf,\n      dominantPageWidth,\n      pageDimensions,\n    }\n  }\n\n  public calculatePagePositions(opts: {\n    pageDimensions: Map<number, { width: number; height: number }>\n    dominantPageWidth: number\n    viewportWidth: number\n    pageGap: number\n  }) {\n    const { pageDimensions, dominantPageWidth, viewportWidth, pageGap } = opts\n    let prevPageHeight = pageGap\n\n    return pageDimensions\n      .entries()\n      .map(([pageNumber, pageDimensions], index) => {\n        const allowedPageWidth = viewportWidth * 0.8\n        const allowedScale =\n          dominantPageWidth > allowedPageWidth\n            ? allowedPageWidth / dominantPageWidth\n            : 1\n\n        const scaledPageWidth = pageDimensions.width * allowedScale\n        const scaledPageHeight = pageDimensions.height * allowedScale\n\n        const yPosition = prevPageHeight + index * pageGap\n        prevPageHeight += scaledPageHeight\n\n        return {\n          pageNumber,\n          dimensions: {\n            width: scaledPageWidth,\n            height: scaledPageHeight,\n          },\n          position: {\n            x: viewportWidth / 2 - scaledPageWidth / 2,\n            y: yPosition,\n          },\n        }\n      })\n      .toArray()\n  }\n\n  public async loadPage(pageNumber: number, scale: number = 1) {\n    if (this.pdf === null) throw new Error('PDF not loaded yet.')\n\n    const page = await this.pdf.getPage(pageNumber)\n    const viewport = page.getViewport({ scale })\n    const outputScale = window.devicePixelRatio || 1\n\n    const canvas = document.createElement('canvas')\n    const context = canvas.getContext('2d')!\n    canvas.width = Math.floor(viewport.width * outputScale)\n    canvas.height = Math.floor(viewport.height * outputScale)\n    canvas.style.width = Math.floor(viewport.width) + 'px'\n    canvas.style.height = Math.floor(viewport.height) + 'px'\n\n    const transform =\n      outputScale !== 1 ? [outputScale, 0, 0, outputScale, 0, 0] : undefined\n    const renderContext = {\n      canvas,\n      canvasContext: context,\n      transform,\n      viewport,\n    }\n\n    await page.render(renderContext).promise\n\n    return {\n      page,\n      canvas,\n    }\n  }\n\n  public dispose() {\n    this.pdfLoaded = false\n    void this.pdf?.destroy()\n  }\n}\n\nfunction calculateYClamping(\n  inputY: number,\n  state: {\n    scale: number\n    pagePositions: ReturnType<PDFLoader['calculatePagePositions']>\n    height: number\n  },\n) {\n  let newY = inputY\n  const scale = state.scale\n  if (newY > GAP_BETWEEN_PAGES_ON_CANVAS * scale)\n    newY = GAP_BETWEEN_PAGES_ON_CANVAS * scale\n\n  // bottom bounds\n  const lastPagePos = state.pagePositions[state.pagePositions.length - 1]\n  const lastPageHeight = lastPagePos.dimensions.height * scale\n  const lastPageY = lastPagePos.position.y * scale\n  const totalDocHeight = lastPageY + lastPageHeight\n  const maxY =\n    totalDocHeight - state.height + GAP_BETWEEN_PAGES_ON_CANVAS * scale * 2\n  if (newY < -maxY) newY = -maxY\n\n  return newY\n}\n\nfunction calculateXClamping(\n  inputX: number,\n  state: {\n    scale: number\n    pagePositions: ReturnType<PDFLoader['calculatePagePositions']>\n    width: number\n    height: number\n    x: number\n  },\n) {\n  const scale = state.scale\n\n  let newX = inputX\n  let largestPagePos = state.pagePositions[0]\n  for (const pagePos of state.pagePositions) {\n    if (pagePos.dimensions.width > largestPagePos.dimensions.width) {\n      largestPagePos = pagePos\n    }\n  }\n\n  const largestPageWidth = largestPagePos.dimensions.width * scale\n  const largestPageX = largestPagePos.position.x * scale\n\n  const docLeft = largestPageX\n  const docRight = largestPageX + largestPageWidth\n\n  if (largestPageWidth <= state.width) {\n    newX = state.x\n  } else {\n    const padding = GAP_BETWEEN_PAGES_ON_CANVAS * scale\n\n    const maxX = padding - docLeft\n    const minX = state.width - docRight - padding\n\n    if (newX > maxX) newX = maxX\n    if (newX < minX) newX = minX\n  }\n\n  return newX\n}\n\nfunction findClosestPage(state: {\n  currentPage: number\n  pagePositions: ReturnType<PDFLoader['calculatePagePositions']>\n  y: number\n  height: number\n  scale: number\n}) {\n  let closestPage = state.currentPage\n  let closestDistance = Infinity\n\n  const viewportTop = -state.y\n  const viewportCenter = viewportTop + state.height / 2\n\n  state.pagePositions.forEach((pos) => {\n    const pageTop = pos.position.y * state.scale\n    const pageBottom = pageTop + pos.dimensions.height * state.scale\n    const pageCenter = (pageTop + pageBottom) / 2\n\n    const distance = Math.abs(pageCenter - viewportCenter)\n    if (distance < closestDistance) {\n      closestDistance = distance\n      closestPage = pos.pageNumber\n    }\n  })\n\n  return closestPage\n}\n\nfunction calculateXForScale(width: number, scale: number) {\n  const centerXOriginal = width / 2\n  const centerXScaled = (width * scale) / 2\n  const diff = Math.abs(centerXOriginal - centerXScaled)\n  const newX = diff * (centerXOriginal > centerXScaled ? 1 : -1)\n\n  return newX\n}\n\nconst PDF_PAGE_LOAD_SCALE = 2\nconst GAP_BETWEEN_PAGES_ON_CANVAS = 24\nconst ZOOM_BY_FACTOR = 1.05\n\ntype PDFViewState = {\n  status: 'loading' | 'success' | 'error'\n  scale: number\n  width: number\n  height: number\n  x: number\n  y: number\n  dominantPageWidth: number\n  pageDimensions: Map<\n    number,\n    {\n      width: number\n      height: number\n    }\n  >\n  pagePositions: ReturnType<PDFLoader['calculatePagePositions']>\n  currentPage: number\n  totalPages: number\n}\nconst PDFViewContext = React.createContext<\n  [PDFViewState, React.Dispatch<React.SetStateAction<PDFViewState>>]\n>(\n  null as unknown as [\n    PDFViewState,\n    React.Dispatch<React.SetStateAction<PDFViewState>>,\n  ],\n)\n\nconst PDFViewActionsContext = React.createContext<{\n  setViewportScale: (scale: number) => void\n  goToPage: (pageNumber: number) => void\n}>(\n  null as unknown as {\n    setViewportScale: (scale: number) => void\n    goToPage: (pageNumber: number) => void\n  },\n)\n\nfunction PDFViewProvider(props: { children: React.ReactNode }) {\n  const [state, setState] = useState<PDFViewState>({\n    status: 'loading',\n\n    scale: 1,\n\n    width: 0,\n    height: 0,\n\n    x: 0,\n    y: 0,\n\n    dominantPageWidth: 0,\n    pageDimensions: new Map(),\n    pagePositions: [],\n\n    currentPage: 1,\n    totalPages: 1,\n  })\n\n  const setViewportScale = useCallback((scale: number) => {\n    setState((state) => {\n      const newX = calculateXForScale(state.width, scale)\n\n      return {\n        ...state,\n        x: newX,\n        scale: scale,\n      }\n    })\n  }, [])\n\n  const goToPage = useCallback((pageNumber: number) => {\n    setState((viewportState) => {\n      const targetPagePos = viewportState.pagePositions.find(\n        (pos) => pos.pageNumber === pageNumber,\n      )\n      if (targetPagePos === undefined) return viewportState\n\n      const targetY =\n        targetPagePos.position.y * viewportState.scale -\n        GAP_BETWEEN_PAGES_ON_CANVAS\n\n      return {\n        ...viewportState,\n        currentPage: pageNumber,\n        y: -targetY,\n      }\n    })\n  }, [])\n\n  return (\n    <PDFViewActionsContext.Provider value={{ setViewportScale, goToPage }}>\n      <PDFViewContext.Provider value={[state, setState]}>\n        {props.children}\n      </PDFViewContext.Provider>\n    </PDFViewActionsContext.Provider>\n  )\n}\n\nfunction PDFView<ContainerRef extends HTMLElement>(props: {\n  src: string\n  containerRef: React.RefObject<ContainerRef | null>\n}) {\n  const context = useContext(PDFViewContext)\n  if (!context) throw new Error('PDFView must be child of PDFViewProvider.')\n\n  const [state, setState] = context\n  const loaderRef = useRef<PDFLoader>(null)\n\n  useEffect(\n    function loadDocumentAndPages() {\n      if (props.containerRef.current === null) return\n\n      const container = props.containerRef.current\n      const rect = container.getBoundingClientRect()\n      setState((prev) => ({\n        ...prev,\n        width: rect.width,\n        height: rect.height,\n      }))\n\n      const loader = new PDFLoader()\n\n      loader\n        .load(props.src, PDF_PAGE_LOAD_SCALE)\n        .then(({ pdf, dominantPageWidth, pageDimensions }) => {\n          const pagePositions = loader.calculatePagePositions({\n            pageDimensions,\n            dominantPageWidth,\n            viewportWidth: rect.width,\n            pageGap: GAP_BETWEEN_PAGES_ON_CANVAS,\n          })\n\n          setState((prev) => ({\n            ...prev,\n            status: 'success',\n            dominantPageWidth,\n            pageDimensions,\n            pagePositions,\n            totalPages: pdf.numPages,\n          }))\n        })\n        .catch((e) => {\n          setState((prev) => ({\n            ...prev,\n            status: 'error',\n          }))\n          console.error('[PDFView] Failed to load document. Cause:', e)\n        })\n      loaderRef.current = loader\n\n      let updatViewportDimensionsTimer: NodeJS.Timeout | null = null\n\n      const resizeObserver = new ResizeObserver((entries) => {\n        const rect = entries[0].contentRect\n\n        if (updatViewportDimensionsTimer !== null) {\n          clearTimeout(updatViewportDimensionsTimer)\n        }\n        updatViewportDimensionsTimer = setTimeout(() => {\n          setState((prev) => {\n            if (prev.dominantPageWidth === 0) return prev\n\n            const pagePositions = loader.calculatePagePositions({\n              pageDimensions: prev.pageDimensions,\n              dominantPageWidth: prev.dominantPageWidth,\n              viewportWidth: rect.width,\n              pageGap: GAP_BETWEEN_PAGES_ON_CANVAS,\n            })\n\n            return {\n              ...prev,\n              pagePositions,\n              width: rect.width,\n              height: rect.height,\n            }\n          })\n        }, 150)\n      })\n\n      resizeObserver.observe(container)\n\n      return () => {\n        resizeObserver.disconnect()\n        loaderRef.current?.dispose()\n      }\n    },\n    [props.src],\n  )\n\n  function handleWheel(e: Konva.KonvaEventObject<WheelEvent>) {\n    e.evt.preventDefault()\n\n    const stage = e.currentTarget as Konva.Stage\n\n    const deltaY = e.evt.deltaY\n    const deltaX = e.evt.deltaX\n    const direction = e.evt.deltaY > 0 ? -1 : 1\n    const zoomBy = e.evt.ctrlKey || e.evt.metaKey ? ZOOM_BY_FACTOR : 1\n    const pointer = stage.getPointerPosition()!\n\n    setState((state) => {\n      if (zoomBy !== 1) {\n        const newScale =\n          direction > 0\n            ? Math.min(state.scale * zoomBy, 3)\n            : Math.max(state.scale / zoomBy, 0.25)\n        const mousePointToY = (pointer.y - state.y) / state.scale\n\n        const newX = calculateXForScale(state.width, newScale)\n        const newY = calculateYClamping(pointer.y - mousePointToY * newScale, {\n          ...state,\n          scale: newScale,\n        })\n\n        return {\n          ...state,\n          y: newY,\n          x: newX,\n          scale: newScale,\n        }\n      }\n\n      const closestPage = findClosestPage(state)\n      const newY = calculateYClamping(state.y - deltaY, state)\n      const newX = calculateXClamping(state.x - deltaX, state)\n\n      return {\n        ...state,\n        currentPage: closestPage,\n        y: newY,\n        x: newX,\n      }\n    })\n  }\n\n  if (state.status === 'loading') {\n    return null\n  }\n\n  const buffer = 2 * state.height\n  const visiblePages = state.pagePositions.filter((pos) => {\n    const pageTop = pos.position.y * state.scale\n    const pageBottom = pageTop + pos.dimensions.height * state.scale\n    const viewportTop = -state.y\n    const viewportBottom = viewportTop + state.height\n\n    return (\n      pageBottom >= viewportTop - buffer && pageTop <= viewportBottom + buffer\n    )\n  })\n\n  return (\n    <Stage\n      scaleX={state.scale}\n      scaleY={state.scale}\n      x={state.x}\n      y={state.y}\n      onWheel={handleWheel}\n      width={state.width}\n      height={state.height}\n      className={cn('overflow-hidden')}>\n      <FastLayer>\n        {visiblePages.map(({ pageNumber, dimensions, position }) => {\n          return (\n            <PDFPage\n              key={pageNumber}\n              loaderRef={loaderRef}\n              pageNumber={pageNumber}\n              dimensions={dimensions}\n              position={position}\n            />\n          )\n        })}\n      </FastLayer>\n    </Stage>\n  )\n}\n\nfunction PDFPage(props: {\n  loaderRef: React.RefObject<PDFLoader | null>\n  pageNumber: number\n  dimensions: { width: number; height: number }\n  position: {\n    x: number\n    y: number\n  }\n}) {\n  const groupRef = useRef<Konva.Group>(null)\n  const [image, setImage] = useState<HTMLCanvasElement | undefined>(undefined)\n\n  useEffect(\n    function loadPage() {\n      const loader = props.loaderRef.current\n      if (loader === null) return\n\n      setTimeout(() => {\n        loader\n          .loadPage(props.pageNumber, PDF_PAGE_LOAD_SCALE)\n          .then(({ canvas }) => {\n            setImage(canvas)\n          })\n          .catch((e) => {\n            console.error('[PDFPage] Failed to load page. Cause:', e)\n          })\n      }, 300)\n    },\n    [props.pageNumber],\n  )\n\n  return (\n    <Group {...props.position} ref={groupRef}>\n      {!image && (\n        <Rect\n          {...props.dimensions}\n          stroke={'#e5e5e5'}\n          fill={'#efefef'}\n          strokeWidth={0.5}\n        />\n      )}\n      {image && (\n        <Image\n          {...props.dimensions}\n          image={image}\n          stroke={'#e5e5e5'}\n          strokeWidth={1}\n        />\n      )}\n    </Group>\n  )\n}\n\nfunction usePDFViewState() {\n  const context = useContext(PDFViewContext)\n  if (!context) throw new Error('PDFView must be child of PDFViewProvider.')\n\n  const [state] = context\n\n  return {\n    status: state.status,\n    scale: state.scale,\n    currentPage: state.currentPage,\n    totalPages: state.totalPages,\n  }\n}\n\nfunction usePDFViewActions() {\n  const context = useContext(PDFViewActionsContext)\n  if (!context) throw new Error('PDFView must be child of PDFViewProvider.')\n\n  return context\n}\n\nexport { PDFView, PDFViewProvider, usePDFViewActions, usePDFViewState }\n",
      "type": "registry:ui"
    }
  ]
}