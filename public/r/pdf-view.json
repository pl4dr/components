{
  "$schema": "https://ui.shadcn.com/schema/registry-item.json",
  "name": "pdf-view",
  "type": "registry:ui",
  "title": "PDF View",
  "description": "PDFV Viewer component",
  "dependencies": [
    "konva",
    "react-konva",
    "pdfjs-dist"
  ],
  "files": [
    {
      "path": "src/registry/pdfview/pdfview.tsx",
      "content": "'use client'\n\nimport { cn } from '@/lib/utils'\nimport {\n  GAP_BETWEEN_PAGES_ON_CANVAS,\n  PDF_PAGE_LOAD_SCALE,\n  ZOOM_BY_FACTOR,\n} from '@/registry/pdfview/pdfview-constants'\nimport { PDFLoader } from '@/registry/pdfview/pdfview-loader'\nimport {\n  calculateMinMaxX,\n  calculateXClamping,\n  calculateXForScale,\n  calculateYClamping,\n  findClosestPage,\n} from '@/registry/pdfview/pdfview-utils'\nimport type Konva from 'konva'\nimport { Vector2d } from 'konva/lib/types'\nimport React, {\n  useCallback,\n  useContext,\n  useEffect,\n  useRef,\n  useState,\n} from 'react'\n\nimport { Group, Image, Layer, Rect, Stage } from 'react-konva'\n\ntype PDFViewState = {\n  status: 'loading' | 'success' | 'error'\n  scale: number\n  width: number\n  height: number\n  x: number\n  y: number\n  dominantPageWidth: number\n  pageDimensions: Map<\n    number,\n    {\n      width: number\n      height: number\n    }\n  >\n  pagePositions: ReturnType<PDFLoader['calculatePagePositions']>\n  currentPage: number\n  totalPages: number\n}\nconst PDFViewContext = React.createContext<\n  [PDFViewState, React.Dispatch<React.SetStateAction<PDFViewState>>]\n>(\n  null as unknown as [\n    PDFViewState,\n    React.Dispatch<React.SetStateAction<PDFViewState>>,\n  ],\n)\n\nconst PDFViewActionsContext = React.createContext<{\n  setViewportScale: (scale: number) => void\n  goToPage: (pageNumber: number) => void\n}>(\n  null as unknown as {\n    setViewportScale: (scale: number) => void\n    goToPage: (pageNumber: number) => void\n  },\n)\n\nfunction PDFViewProvider(props: { children: React.ReactNode }) {\n  const [state, setState] = useState<PDFViewState>({\n    status: 'loading',\n\n    scale: 1,\n\n    width: 0,\n    height: 0,\n\n    x: 0,\n    y: 0,\n\n    dominantPageWidth: 0,\n    pageDimensions: new Map(),\n    pagePositions: [],\n\n    currentPage: 1,\n    totalPages: 1,\n  })\n\n  const setViewportScale = useCallback((scale: number) => {\n    setState((state) => {\n      const newX = calculateXForScale(state.width, scale)\n\n      return {\n        ...state,\n        x: newX,\n        scale: scale,\n      }\n    })\n  }, [])\n\n  const goToPage = useCallback((pageNumber: number) => {\n    setState((viewportState) => {\n      const targetPagePos = viewportState.pagePositions.find(\n        (pos) => pos.pageNumber === pageNumber,\n      )\n      if (targetPagePos === undefined) return viewportState\n\n      const targetY =\n        targetPagePos.position.y * viewportState.scale -\n        GAP_BETWEEN_PAGES_ON_CANVAS\n\n      return {\n        ...viewportState,\n        currentPage: pageNumber,\n        y: -targetY,\n      }\n    })\n  }, [])\n\n  return (\n    <PDFViewActionsContext.Provider value={{ setViewportScale, goToPage }}>\n      <PDFViewContext.Provider value={[state, setState]}>\n        {props.children}\n      </PDFViewContext.Provider>\n    </PDFViewActionsContext.Provider>\n  )\n}\n\nfunction remapRange(\n  x: number,\n  minO: number,\n  maxO: number,\n  dMin: number,\n  dMax: number,\n): number {\n  return dMin + ((x - minO) / (maxO - minO)) * (dMax - dMin)\n}\n\nfunction invertRemapRange(\n  xNew: number,\n  minO: number,\n  maxO: number,\n  dMin: number,\n  dMax: number,\n): number {\n  return minO + ((xNew - dMin) / (dMax - dMin)) * (maxO - minO)\n}\n\nfunction ScrollbarY(props: {\n  state: PDFViewState\n  onYUpdate: (y: number) => void\n}) {\n  const { state } = props\n\n  const lastPagePos = state.pagePositions[state.pagePositions.length - 1]\n  const contentH =\n    lastPagePos.position.y +\n    lastPagePos.dimensions.height +\n    GAP_BETWEEN_PAGES_ON_CANVAS * 2\n  const scaledContentH = contentH * state.scale\n\n  const viewH = state.height\n  const verticalRatio = viewH / scaledContentH\n  const vLen = Math.max(20, viewH * verticalRatio)\n\n  const minY = 2 * state.scale\n  const maxY = state.height - (minY + 10)\n\n  const dY = remapRange(\n    -state.y,\n    -GAP_BETWEEN_PAGES_ON_CANVAS,\n    scaledContentH,\n    minY,\n    maxY,\n  )\n\n  const [dragging, setDragging] = useState(false)\n\n  function dragBoundFunc(pos: Vector2d) {\n    let newY = pos.y\n\n    if (newY < minY) newY = minY\n    if (newY > maxY - vLen) newY = maxY - vLen\n\n    return {\n      y: newY,\n      x: state.width - 9,\n    }\n  }\n\n  return (\n    <Rect\n      draggable\n      dragBoundFunc={dragBoundFunc}\n      onDragStart={() => setDragging(true)}\n      onDragMove={(e) => {\n        const { y: yPos } = e.currentTarget.position()\n\n        let newY = -invertRemapRange(\n          yPos,\n          -GAP_BETWEEN_PAGES_ON_CANVAS,\n          scaledContentH,\n          minY,\n          maxY,\n        )\n        props.onYUpdate(newY)\n      }}\n      onDragEnd={() => setDragging(false)}\n      y={dragging ? undefined : dY}\n      x={state.width - 9}\n      width={6}\n      height={vLen}\n      fill=\"#c9c9c9\"\n      cornerRadius={3}\n    />\n  )\n}\n\nfunction ScrollbarX(props: {\n  state: PDFViewState\n  onXUpdate: (x: number) => void\n}) {\n  const { state } = props\n  const stageW = state.width\n  const horizontalRatio = stageW / (stageW * state.scale)\n  const hLen = stageW * horizontalRatio\n\n  const { minX, maxX } = calculateMinMaxX(state)\n  const newMaxX = stageW - hLen\n  const dX = remapRange(state.x, minX, maxX, newMaxX, 0)\n  const showHScrollbar = state.scale > 1.05\n\n  const [dragging, setDragging] = useState(false)\n\n  function dragBoundFunc(pos: Vector2d) {\n    let newX = pos.x\n\n    if (newX >= newMaxX) newX = newMaxX\n    if (newX < 0) newX = 0\n\n    return {\n      y: state.height - 8,\n      x: newX,\n    }\n  }\n\n  if (!showHScrollbar) return null\n\n  return (\n    <Rect\n      draggable\n      dragBoundFunc={dragBoundFunc}\n      onDragStart={() => setDragging(true)}\n      onDragEnd={() => setDragging(false)}\n      onDragMove={(e) => {\n        const { x: xPos } = e.currentTarget.position()\n\n        let newX = invertRemapRange(xPos, minX, maxX, newMaxX, 0)\n\n        props.onXUpdate(newX)\n      }}\n      x={dragging ? undefined : dX}\n      y={state.height - 8}\n      width={hLen}\n      height={6}\n      fill=\"#c9c9c9\"\n      cornerRadius={3}\n    />\n  )\n}\n\nfunction PDFView<ContainerRef extends HTMLElement>(props: {\n  src: string\n  containerRef: React.RefObject<ContainerRef | null>\n}) {\n  const context = useContext(PDFViewContext)\n  if (!context) throw new Error('PDFView must be child of PDFViewProvider.')\n\n  const [state, setState] = context\n  const loaderRef = useRef<PDFLoader>(null)\n\n  useEffect(\n    function loadDocumentAndPages() {\n      if (props.containerRef.current === null) return\n\n      const container = props.containerRef.current\n      const rect = container.getBoundingClientRect()\n      setState((prev) => ({\n        ...prev,\n        width: rect.width,\n        height: rect.height,\n      }))\n\n      const loader = new PDFLoader()\n\n      loader\n        .load(props.src, PDF_PAGE_LOAD_SCALE)\n        .then(({ pdf, dominantPageWidth, pageDimensions }) => {\n          const pagePositions = loader.calculatePagePositions({\n            pageDimensions,\n            dominantPageWidth,\n            viewportWidth: rect.width,\n            pageGap: GAP_BETWEEN_PAGES_ON_CANVAS,\n          })\n\n          setState((prev) => ({\n            ...prev,\n            status: 'success',\n            dominantPageWidth,\n            pageDimensions,\n            pagePositions,\n            totalPages: pdf.numPages,\n          }))\n        })\n        .catch((e) => {\n          setState((prev) => ({\n            ...prev,\n            status: 'error',\n          }))\n          console.error('[PDFView] Failed to load document. Cause:', e)\n        })\n      loaderRef.current = loader\n\n      let updatViewportDimensionsTimer: NodeJS.Timeout | null = null\n\n      const resizeObserver = new ResizeObserver((entries) => {\n        const rect = entries[0].contentRect\n\n        if (updatViewportDimensionsTimer !== null) {\n          clearTimeout(updatViewportDimensionsTimer)\n        }\n        updatViewportDimensionsTimer = setTimeout(() => {\n          setState((prev) => {\n            if (prev.dominantPageWidth === 0) return prev\n\n            const pagePositions = loader.calculatePagePositions({\n              pageDimensions: prev.pageDimensions,\n              dominantPageWidth: prev.dominantPageWidth,\n              viewportWidth: rect.width,\n              pageGap: GAP_BETWEEN_PAGES_ON_CANVAS,\n            })\n\n            return {\n              ...prev,\n              pagePositions,\n              width: rect.width,\n              height: rect.height,\n            }\n          })\n        }, 150)\n      })\n\n      resizeObserver.observe(container)\n\n      return () => {\n        resizeObserver.disconnect()\n        loaderRef.current?.dispose()\n      }\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [props.src],\n  )\n\n  function handleWheelLayer(e: Konva.KonvaEventObject<WheelEvent>) {\n    e.evt.preventDefault()\n\n    const layer = e.currentTarget as Konva.Layer\n    const stage = layer.getStage()\n\n    const deltaY = e.evt.deltaY\n    const deltaX = e.evt.deltaX\n    const pointer = stage.getPointerPosition()!\n\n    const modPressed = e.evt.ctrlKey || e.evt.metaKey\n\n    updateStateOnWheel({ deltaX, deltaY, modPressed, pointer })\n  }\n\n  function handleWheelStage(e: Konva.KonvaEventObject<WheelEvent>) {\n    e.evt.preventDefault()\n\n    const stage = e.currentTarget as Konva.Stage\n\n    const deltaY = e.evt.deltaY\n    const deltaX = e.evt.deltaX\n    const pointer = stage.getPointerPosition()!\n\n    const modPressed = e.evt.ctrlKey || e.evt.metaKey\n\n    updateStateOnWheel({ deltaX, deltaY, modPressed, pointer })\n  }\n\n  function updateStateOnWheel(params: {\n    deltaX: number\n    deltaY: number\n    modPressed: boolean\n    pointer: Konva.Vector2d\n  }) {\n    const deltaY = params.deltaY\n    const deltaX = params.deltaX\n    const direction = params.deltaY > 0 ? -1 : 1\n    const zoomBy = params.modPressed ? ZOOM_BY_FACTOR : 1\n    const pointer = params.pointer\n\n    setState((state) => {\n      if (zoomBy !== 1) {\n        const newScale =\n          direction > 0\n            ? Math.min(state.scale * zoomBy, 3)\n            : Math.max(state.scale / zoomBy, 0.25)\n        const mousePointToY = (pointer.y - state.y) / state.scale\n\n        const newX = calculateXForScale(state.width, newScale)\n        const newY = calculateYClamping(pointer.y - mousePointToY * newScale, {\n          ...state,\n          scale: newScale,\n        })\n\n        return {\n          ...state,\n          y: newY,\n          x: newX,\n          scale: newScale,\n        }\n      }\n\n      const closestPage = findClosestPage(state)\n      const newY = calculateYClamping(state.y - deltaY, state)\n      const newX = calculateXClamping(state.x - deltaX, state)\n\n      return {\n        ...state,\n        currentPage: closestPage,\n        y: newY,\n        x: newX,\n      }\n    })\n  }\n\n  if (state.status === 'loading') {\n    return null\n  }\n\n  const buffer = 2 * state.height\n  const visiblePages = state.pagePositions.filter((pos) => {\n    const pageTop = pos.position.y * state.scale\n    const pageBottom = pageTop + pos.dimensions.height * state.scale\n    const viewportTop = -state.y\n    const viewportBottom = viewportTop + state.height\n\n    return (\n      pageBottom >= viewportTop - buffer && pageTop <= viewportBottom + buffer\n    )\n  })\n\n  return (\n    <Stage\n      width={state.width}\n      height={state.height}\n      onWheel={handleWheelStage}\n      className={cn('overflow-hidden')}>\n      <Layer\n        scaleX={state.scale}\n        scaleY={state.scale}\n        x={state.x}\n        y={state.y}\n        onWheel={handleWheelLayer}>\n        {visiblePages.map(({ pageNumber, dimensions, position }) => {\n          return (\n            <PDFPage\n              key={pageNumber}\n              loaderRef={loaderRef}\n              pageNumber={pageNumber}\n              dimensions={dimensions}\n              position={position}\n            />\n          )\n        })}\n      </Layer>\n\n      <Layer>\n        <ScrollbarY\n          state={state}\n          onYUpdate={(y) => setState((prev) => ({ ...prev, y }))}\n        />\n        <ScrollbarX\n          state={state}\n          onXUpdate={(x) => setState((prev) => ({ ...prev, x }))}\n        />\n      </Layer>\n    </Stage>\n  )\n}\n\nfunction PDFPage(props: {\n  loaderRef: React.RefObject<PDFLoader | null>\n  pageNumber: number\n  dimensions: { width: number; height: number }\n  position: {\n    x: number\n    y: number\n  }\n}) {\n  const groupRef = useRef<Konva.Group>(null)\n  const [image, setImage] = useState<HTMLCanvasElement | undefined>(undefined)\n\n  useEffect(\n    function loadPage() {\n      const loader = props.loaderRef.current\n      if (loader === null) return\n\n      setTimeout(() => {\n        loader\n          .loadPage(props.pageNumber, PDF_PAGE_LOAD_SCALE)\n          .then(({ canvas }) => {\n            setImage(canvas)\n          })\n          .catch((e) => {\n            console.error('[PDFPage] Failed to load page. Cause:', e)\n          })\n      }, 300)\n    },\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    [props.pageNumber],\n  )\n\n  return (\n    <Group {...props.position} ref={groupRef}>\n      {!image && (\n        <Rect\n          {...props.dimensions}\n          stroke={'#e5e5e5'}\n          fill={'#efefef'}\n          strokeWidth={0.5}\n        />\n      )}\n      {image && (\n        <Image\n          {...props.dimensions}\n          image={image}\n          stroke={'#e5e5e5'}\n          strokeWidth={1}\n          alt={`Page ${props.pageNumber}`}\n        />\n      )}\n    </Group>\n  )\n}\n\nfunction usePDFViewState() {\n  const context = useContext(PDFViewContext)\n  if (!context) throw new Error('PDFView must be child of PDFViewProvider.')\n\n  const [state] = context\n\n  return {\n    status: state.status,\n    scale: state.scale,\n    currentPage: state.currentPage,\n    totalPages: state.totalPages,\n  }\n}\n\nfunction usePDFViewActions() {\n  const context = useContext(PDFViewActionsContext)\n  if (!context) throw new Error('PDFView must be child of PDFViewProvider.')\n\n  return context\n}\n\nexport { PDFView, PDFViewProvider, usePDFViewActions, usePDFViewState }\n",
      "type": "registry:ui"
    },
    {
      "path": "src/registry/pdfview/pdfview-utils.ts",
      "content": "import { GAP_BETWEEN_PAGES_ON_CANVAS } from '@/registry/pdfview/pdfview-constants'\nimport type { PDFLoader } from '@/registry/pdfview/pdfview-loader'\n\nexport function calculateYClamping(\n  inputY: number,\n  state: {\n    scale: number\n    pagePositions: ReturnType<PDFLoader['calculatePagePositions']>\n    height: number\n  },\n) {\n  let newY = inputY\n  const scale = state.scale\n  if (newY > GAP_BETWEEN_PAGES_ON_CANVAS * scale)\n    newY = GAP_BETWEEN_PAGES_ON_CANVAS * scale\n\n  // bottom bounds\n  const lastPagePos = state.pagePositions[state.pagePositions.length - 1]\n  const lastPageHeight = lastPagePos.dimensions.height * scale\n  const lastPageY = lastPagePos.position.y * scale\n  const totalDocHeight = lastPageY + lastPageHeight\n  const maxY =\n    totalDocHeight - state.height + GAP_BETWEEN_PAGES_ON_CANVAS * scale * 2\n  if (newY < -maxY) newY = -maxY\n\n  return newY\n}\n\nexport function calculateMinMaxX(state: {\n  scale: number\n  pagePositions: ReturnType<PDFLoader['calculatePagePositions']>\n  width: number\n  height: number\n  x: number\n}) {\n  const scale = state.scale\n  let largestPagePos = state.pagePositions[0]\n  for (const pagePos of state.pagePositions) {\n    if (pagePos.dimensions.width > largestPagePos.dimensions.width) {\n      largestPagePos = pagePos\n    }\n  }\n\n  const largestPageWidth = largestPagePos.dimensions.width * scale\n  const largestPageX = largestPagePos.position.x * scale\n\n  const docLeft = largestPageX\n  const docRight = largestPageX + largestPageWidth\n\n  const padding = GAP_BETWEEN_PAGES_ON_CANVAS * scale\n\n  const maxX = padding - docLeft\n  const minX = state.width - docRight - padding\n\n  return { minX, maxX, largestPageWidth }\n}\n\nexport function calculateXClamping(\n  inputX: number,\n  state: {\n    scale: number\n    pagePositions: ReturnType<PDFLoader['calculatePagePositions']>\n    width: number\n    height: number\n    x: number\n  },\n) {\n  const { minX, maxX, largestPageWidth } = calculateMinMaxX(state)\n  let newX = inputX\n  if (largestPageWidth <= state.width) {\n    newX = state.x\n  } else {\n    if (newX > maxX) newX = maxX\n    if (newX < minX) newX = minX\n  }\n\n  return newX\n}\n\nexport function findClosestPage(state: {\n  currentPage: number\n  pagePositions: ReturnType<PDFLoader['calculatePagePositions']>\n  y: number\n  height: number\n  scale: number\n}) {\n  let closestPage = state.currentPage\n  let closestDistance = Infinity\n\n  const viewportTop = -state.y\n  const viewportCenter = viewportTop + state.height / 2\n\n  state.pagePositions.forEach((pos) => {\n    const pageTop = pos.position.y * state.scale\n    const pageBottom = pageTop + pos.dimensions.height * state.scale\n    const pageCenter = (pageTop + pageBottom) / 2\n\n    const distance = Math.abs(pageCenter - viewportCenter)\n    if (distance < closestDistance) {\n      closestDistance = distance\n      closestPage = pos.pageNumber\n    }\n  })\n\n  return closestPage\n}\n\nexport function calculateXForScale(width: number, scale: number) {\n  const centerXOriginal = width / 2\n  const centerXScaled = (width * scale) / 2\n  const diff = Math.abs(centerXOriginal - centerXScaled)\n  const newX = diff * (centerXOriginal > centerXScaled ? 1 : -1)\n\n  return newX\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "src/registry/pdfview/pdfview-loader.ts",
      "content": "import type {\n  DocumentInitParameters,\n  TypedArray,\n} from 'pdfjs-dist/types/src/display/api'\n\nimport * as pdfjs from 'pdfjs-dist'\n\npdfjs.GlobalWorkerOptions.workerSrc = new URL(\n  'pdfjs-dist/build/pdf.worker.min.mjs',\n  import.meta.url,\n).toString()\n\nexport class PDFLoader {\n  public pdf!: pdfjs.PDFDocumentProxy\n  public pdfLoaded = false\n\n  public async load(\n    src: string | URL | TypedArray | ArrayBuffer | DocumentInitParameters,\n    pageScale: number = 1,\n  ) {\n    const pdf = await pdfjs.getDocument(src).promise\n    this.pdf = pdf\n    this.pdfLoaded = true\n\n    const pages = await Promise.all(\n      Array.from({ length: pdf.numPages }).map((_, i) => pdf.getPage(i + 1)),\n    )\n    const pageDimensions = new Map<\n      number,\n      {\n        width: number\n        height: number\n      }\n    >()\n    const pageWidths = new Map<number, number>()\n    pages.forEach((page) => {\n      const viewport = page.getViewport({ scale: pageScale })\n      const v = pageWidths.get(viewport.width) ?? 1\n      pageWidths.set(viewport.width, v + 1)\n      pageDimensions.set(page.pageNumber, {\n        width: viewport.width,\n        height: viewport.height,\n      })\n    })\n    const reversedMap = new Map(\n      pageWidths.entries().map(([k, v]) => [v, k] as [number, number]),\n    )\n\n    const max = Math.max(...reversedMap.keys())\n    const dominantPageWidth = reversedMap.get(max)\n\n    if (!dominantPageWidth) {\n      throw new Error('Failed to get major page width')\n    }\n\n    return {\n      pdf,\n      dominantPageWidth,\n      pageDimensions,\n    }\n  }\n\n  public calculatePagePositions(opts: {\n    pageDimensions: Map<number, { width: number; height: number }>\n    dominantPageWidth: number\n    viewportWidth: number\n    pageGap: number\n  }) {\n    const { pageDimensions, dominantPageWidth, viewportWidth, pageGap } = opts\n    let prevPageHeight = pageGap\n\n    return pageDimensions\n      .entries()\n      .map(([pageNumber, pageDimensions], index) => {\n        const allowedPageWidth = viewportWidth * 0.8\n        const allowedScale =\n          dominantPageWidth > allowedPageWidth\n            ? allowedPageWidth / dominantPageWidth\n            : 1\n\n        const scaledPageWidth = pageDimensions.width * allowedScale\n        const scaledPageHeight = pageDimensions.height * allowedScale\n\n        const yPosition = prevPageHeight + index * pageGap\n        prevPageHeight += scaledPageHeight\n\n        return {\n          pageNumber,\n          dimensions: {\n            width: scaledPageWidth,\n            height: scaledPageHeight,\n          },\n          position: {\n            x: viewportWidth / 2 - scaledPageWidth / 2,\n            y: yPosition,\n          },\n        }\n      })\n      .toArray()\n  }\n\n  public async loadPage(pageNumber: number, scale: number = 1) {\n    if (this.pdf === null) throw new Error('PDF not loaded yet.')\n\n    const page = await this.pdf.getPage(pageNumber)\n    const viewport = page.getViewport({ scale })\n    const outputScale = window.devicePixelRatio || 1\n\n    const canvas = document.createElement('canvas')\n    const context = canvas.getContext('2d')!\n    canvas.width = Math.floor(viewport.width * outputScale)\n    canvas.height = Math.floor(viewport.height * outputScale)\n    canvas.style.width = Math.floor(viewport.width) + 'px'\n    canvas.style.height = Math.floor(viewport.height) + 'px'\n\n    const transform =\n      outputScale !== 1 ? [outputScale, 0, 0, outputScale, 0, 0] : undefined\n    const renderContext = {\n      canvas,\n      canvasContext: context,\n      transform,\n      viewport,\n    }\n\n    await page.render(renderContext).promise\n\n    return {\n      page,\n      canvas,\n    }\n  }\n\n  public dispose() {\n    this.pdfLoaded = false\n    void this.pdf?.destroy()\n  }\n}\n",
      "type": "registry:lib"
    },
    {
      "path": "src/registry/pdfview/pdfview-constants.ts",
      "content": "export const PDF_PAGE_LOAD_SCALE = 2\nexport const GAP_BETWEEN_PAGES_ON_CANVAS = 24\nexport const ZOOM_BY_FACTOR = 1.05\n",
      "type": "registry:lib"
    }
  ]
}